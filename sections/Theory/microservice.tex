\subsection{Microservice}

Wie aus dem vorhergehenden Abschnitt hervor geht sind Microservices einzelne, unabhängige Services, die um eine Geschäftsdomäne modelliert sind, welche auf Grundlage der klaren Schnittstellen entkoppelt und durch einzelne Kontext begrenzt sind. Die Kontexte ermöglichen das Verwenden von Service internen Terminologie und Verwendung ausschließlich benötigter Daten. Abschließend hat \cref{sec:conway} gezeigt, dass nur ein Team für ein Service zuständig ist.

In seinem Buch \textit{Monolith to Microservices} geht Newman darauf ein, dass wohl die wichtigste Eigenschaft von einem Microservice die unabhängige Einsetzbarkeit ist \parencite[vgl.][Kap. 2.1.1]{newman_monolith_2019}. Er sieht darin die Verkörperung von Unabhängigkeit und eigenständigen Teams, welche durch die Kommunikation der Services durch standardisierte Schnittstellen ermöglicht wird. Die meist verbreitete Art der Schnittstelle ist die nach dem REST-Standard, welche sich an eine Kommunikation über HTTP richtet (siehe \cref{sec:rest}).
 
Da viele Programmiersprachen den Informationsaustausch über HTTP ermöglichen, ist ein Microservice unabhängig einer bestimmten Technologie. Somit kann jedes Team eigenständig entscheiden, welche Programmiersprache sie verwenden wollen \parencite[vgl.][Kap. 1.2]{wolff_microservices_2018}. Dadurch können Sprachen nach Präferenz und Problemstellen gewählt werden, ohne dass eine Inkompatibilität zum Rest des Systems entsteht.

Vielmehr ermöglicht der Austausch über standardisierten Kommunikationswege, dass Services erstellt werden, die austauschbar sind \parencite[vgl.][Kap. 1.2]{wolff_microservices_2018}. Somit können z.B. einige Services durch Dienste von Drittanbieter ausgeführt werden und Entwicklungskosten gespart werden. Außerdem wird dadurch die Möglichkeit geschaffen auf bestehender Logik aufzubauen und ältere Systeme mit modernen Technologien zu verbinden.

\cref{sec:ddd} hat gezeigt das Kontextgrenzen Microservices es ermöglicht Daten nach eigenem ermessen zu benennen und zu verwalten. Konkret besitzt jeder Dienst eine eigene Datenspeicherung, in Form z.B. eines File-Storage-Systems oder einer Datenbank \parencite[vgl.][Kap. 2.1.3]{newman_monolith_2019}. Für das Gesamtsystem bedeutet dies, dass keine einheitliche Datenspeicherung vorliegt, sondern jeder Service die notwendigen Informationen verwaltet. Um jedoch die Funktionalität des gesamten Systems zu erhalten, müssen im Vorfeld bestimmt werden, wie der Informationsaustausch zwischen den Services abläuft \parencite[vgl.][Kap. 4.1]{wolff_microservices_2018}. Hierfür ist es wichtig zu bestimmen, welche Services welche Informationen verwalten und falls Abhängigkeiten zu anderen Diensten bestehen, die Schnittstellen festzulegen. Insbesondere die genauen Endpunkt und die zu erwarteten Informationen müssen bestimmt werden. Die Handhabung innerhalb eines Services, ist dann wieder dem einzelnem Team überlassen. 

Gibt es ein Service, der Informationen von einem anderen Dienst benötigt, fordert dieser die Daten über öffentliche Schnittstellen aktive an. Dies führt jedoch dazu, dass gleiche Informationen von mehrere Diensten verwaltet werden und es zu unterschieden Datenständen kommt \parencite[vgl.][Kap. 4.1]{wolff_microservices_2018}. Es entsteht die Herausforderung Informationen zwischen Services Konsistent zu halten.

Volle Unabhängigkeit eines Microservice kann nur erreicht werden, wenn dieser auch für die Benutzeroberfläche verantwortlich ist \parencite[vgl.][Kap. 4.4]{wolff_microservices_2018}. In der Praxis ist dies jedoch schwierig, da eine Webseite Inhalte von mehreren Services anzeigt. Insbesondere nachdem AngularJS\footnote{AngularJS ist ein JavaScript Framework, welches 2010 von Google entwickelt wurde und eine Open-Source-Software ist \parencite{angularjs}.} veröffentlicht wurde, gibt es immer mehr JavaScript Frameworks die um die Benutzererfahrung zu verbessern mehr Logik in das Frontend legen. React.js ist eines dieser Frameworks. Die Beliebtheit hinter diesen Frameworks, liegt darin, dass jede einzelne Webseite nicht mehr als einzelne Seite betrachtet wird, sondern Informationen zwischen Benutzeroberflächen hinweg verwaltet werden \parencite[vgl.][Kap. 9.1]{wolff_microservices_2018}. Dadurch kann ein Datenabruf über mehrere Webseiten geteilt werden und somit die Performance verbessern. Erreicht wird dies, indem das Routing zwischen den Webseiten durch das Framework verwaltet wird. Dieser Ansatz wird als Single-Page-Application (SPA) bezeichnet und unterscheidet sich von der Idee des Model-View-Controller aus \cref{sec:mvc}, da die nötigen Informationen aktive von der View geladen werden \parencite{single-page-webanwendung_2019}.

Da in der Praxis viele Webseiten Single-Page-Applicationen einsetzen, um eine gute Benutzererfahrung zu liefern, sollte in diesen Fällen über mögliche Teilung nachgedacht werden. Insbesondere wenn es sich um Applikationen handelt, die von mehrere Teams verwaltet werden. Ist dies nämlich der Fall, kann darunter die Unabhängigkeit der Teams leiden.

Auch kann es vorkommen, dass ein Microservices keine graphische Darstellung benötigt, da dieser z.B. nur E-Mails verschickt oder die beliebtesten Filme ermittelt. Somit gibt es keine absolute Aussage darüber, ob ein Microservice eine Benutzeroberfläche haben sollte.

Insbesondere in puncto Skalierung bieten Microservices viele Vorteile \parencite[vgl.][Kap. 2.1.4]{newman_monolith_2019}. So lassen sich individuell, intensiv genutzte Services unabhängig vom Gesamtsystem skalieren. Dies kann ein großer Kostenvorteil sein, da nur ein einzelner Teil und nicht das gesamte System mehr Ressourcen zu geteilt werden muss. Auch können auf Basis der eingeteilten Teams weitere Entwickler angestellt werden und das Unternehmen hinsichtlich der Angestellten wachsen.

Während Microservices Skalierungen begünstigen, erschweren sie serviceübergreifende Veränderungen \parencite[vgl.][Kap. 2.15]{newman_monolith_2019}. Somit ist es auf Grund der technologischen Freiheit aufwendiger, Entwickler von einem Service zu einem Anderen zu überführen. Dies wird dadurch verstärkt, dass unterschiedliche Daten gespeichert und verschiedene Terminologien verwendet werden. Auch eine technologische Überführung von Funktionen wird erschwert, wenn verschiedene Programmiersprachen eingesetzt werden. Äquivalent ist das zusammenführen von Datenschemata, welches durch die unterschiedlichen Attributbezeichnungen boykottiert wird. Dies führt dazu, dass ein Zusammenschluss nur durch einen großen Aufwand erreicht werden kann.

