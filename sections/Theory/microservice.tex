\subsection{Microservice}

Microservices sind einzelne, unabhängige Services, die um eine Geschäftsdomäne modelliert sind, die auf Grundlage der klaren Schnittstellen entkoppelt und durch einzelne Kontexte begrenzt sind. Die Kontexte ermöglichen das Verwenden von serviceinterner Terminologie und die Verwendung ausschließlich benötigter Daten. Wie in \cref{sec:conway} aufgezeigt, ist nur ein Team für einen Service zuständig.

In seinem Buch \textit{Monolith to Microservices} (2019) geht Newman darauf ein, dass die wichtigste Eigenschaft von einem Microservice die unabhängige Einsetzbarkeit ist \parencite[vgl.][Kap. 2.1.1]{newman_monolith_2019}. Er sieht darin die Verkörperung von Unabhängigkeit und eigenständigen Teams, welche durch die Kommunikation der Services durch standardisierte Schnittstellen ermöglicht wird. Die verbreitetste Art der Schnittstelle ist jene nach dem REST-Standard, welche sich an eine Kommunikation über HTTP richtet (siehe \cref{sec:rest}).
 
Da viele Programmiersprachen den Informationsaustausch über HTTP ermöglichen, ist ein Microservice unabhängig von einer bestimmten Technologie. Jedes Team kann eigenständig entscheiden, welche Programmiersprache es verwenden will \parencite[vgl.][Kap. 1.2]{wolff_microservices_2018}. So können Sprachen nach Präferenz und Problemstellungen gewählt werden, ohne dass eine Inkompatibilität zum Rest des Systems entsteht.

Der Austausch über standardisierte Kommunikationswege ermöglicht, dass Services erstellt werden, die austauschbar sind \parencite[vgl.][Kap. 1.2]{wolff_microservices_2018}. Das hat zur Folge, dass z.~B. einige Services durch Dienste von Drittanbietern ausgeführt und Entwicklungskosten eingespart werden. Es wird dadurch auch die Möglichkeit geschaffen, auf bestehender Logik aufzubauen und ältere Systeme mit modernen Technologien zu verbinden.

Wie in \cref{sec:ddd} beschrieben, ermöglichen es Kontextgrenzen, Daten nach eigenem ermessen zu benennen und zu verwalten. Jeder Dienst besitzt eine eigene Datenspeicherung, z.~B. in Form eines File-Storage-Systems oder einer Datenbank \parencite[vgl.][Kap. 2.1.3]{newman_monolith_2019}. Das bedeutet für das Gesamtsystem: keine einheitliche Datenspeicherung und jeder Service verwaltet die notwendigen Informationen eigenständig. Zum Erhalt der Funktionalität des gesamten Systems, muss im Vorfeld bestimmt werden, wie der Informationsaustausch zwischen den Services abläuft \parencite[vgl.][Kap. 4.1]{wolff_microservices_2018}. Es muss festgelegt werden, welche Services welche Informationen verwalten und bei Abhängigkeiten zu anderen Diensten sind die Schnittstellen festzulegen. Insbesondere die genauen Endpunkte und die zu erwarteten Informationen müssen bestimmt werden. Die Handhabung innerhalb eines Services obliegt dann wieder dem einzelnen Team. 

Gibt es einen Service, der Informationen von einem anderen Dienst benötigt, fordert dieser die Daten über öffentliche Schnittstellen aktiv an. Durch die Verwaltung identischer Informationen durch mehrere Dienste kommt es jedoch zu unterschiedlichen Datenständen \parencite[vgl.][Kap. 4.1]{wolff_microservices_2018}. So besteht die Herausforderung, Informationen zwischen Services konsistent zu halten.

Die volle Unabhängigkeit eines Microservice kann nur erreicht werden, wenn dieser auch für die Benutzeroberfläche verantwortlich ist \parencite[vgl.][Kap. 4.4]{wolff_microservices_2018}. In der Praxis ist dies jedoch schwierig, da eine Webseite Inhalte von mehreren Services anzeigt. Besonders nach der Veröffentlichung von AngularJS\footnotemark gibt es immer mehr JavaScript Frameworks, die zur Verbesserung der Benutzererfahrung mehr Logik in das Frontend legen. React.js ist eines dieser Frameworks.
Die Beliebtheit dieser Frameworks kommt daher, dass jede Webseite nicht mehr als einzelne Seite betrachtet wird, sondern Informationen zwischen Benutzeroberflächen hinweg verwaltet werden \parencite[vgl.][Kap. 9.1]{wolff_microservices_2018}. Ein Datenabruf kann über mehrere Webseiten hinweg geteilt werden, wodurch die Performance verbessert wird. Das Routing zwischen den Webseiten wird durch das Framework verwaltet. Dieser Ansatz wird als Single-Page-Application (SPA) bezeichnet. Da die nötigen Informationen aktive von der View geladen werden, unterscheidet sich das von der Idee des MVC-Ansatzes \parencite{single-page-webanwendung_2019}.

\footnotetext{AngularJS ist ein JavaScript Framework, welches 2010 von Google entwickelt wurde und eine Open-Source-Software ist \parencite{angularjs}.}

Auch kann es vorkommen, dass ein Microservice keine graphische Darstellung benötigt, da dieser ausschließlich E-Mails verschickt oder die beliebtesten Filme ermittelt. Folglich ist es umstritten, ob Microservices immer eine Benutzeroberfläche haben sollten.

Auf Skalierung bezogen, bieten Microservices viele Vorteile \parencite[vgl.][Kap. 2.1.4]{newman_monolith_2019}. So lassen sich, unabhängig vom Gesamtsystem, intensiv genutzte Services individuell skalieren. Kosten können eingespart werden, da nur einem einzelnem Teil und nicht dem gesamten System mehr Ressourcen zugeteilt werden.

Während Microservices Skalierungen begünstigen, erschweren sie serviceübergreifende Veränderungen \parencite[vgl.][Kap. 2.15]{newman_monolith_2019}. Auf Grund der technologischen Freiheit ist es aufwendiger Entwickler von einem Service zu einem anderen zu überführen. Verstärkt wird dies durch die Speicherung unterschiedlicher Daten und die Verwendung verschiedener Terminologien. Die technologische Überführung von Funktionen wird durch den Einsatz von verschiedenen Programmiersprachen erschwert. Äquivalent ist das Zusammenführen von Datenschemata, welches durch die unterschiedlichen Attributbezeichnungen boykottiert wird. Dies führt dazu, dass ein Zusammenschluss nur durch einen großen Aufwand erreicht werden kann.

