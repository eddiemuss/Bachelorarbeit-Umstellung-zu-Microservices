\subsection{Microservice}

Microservices sind einzelne, unabhängige Services, die um eine Geschäftsdomäne modelliert sind, die auf Grundlage der klaren Schnittstellen entkoppelt und durch einzelne Kontexte begrenzt sind. Die Kontexte ermöglichen das Verwenden von Services interner Terminologie und die Verwendung ausschließlich benötigter Daten. Wie in \cref{sec:conway} aufgezeigt, ist nur ein Team für einen Service zuständig.

In seinem Buch \textit{Monolith to Microservices} geht Newman darauf ein, dass die wichtigste Eigenschaft von einem Microservice die unabhängige Einsetzbarkeit ist \parencite[vgl.][Kap. 2.1.1]{newman_monolith_2019}. Er sieht darin die Verkörperung von Unabhängigkeit und eigenständigen Teams, welche durch die Kommunikation der Services durch standardisierte Schnittstellen ermöglicht wird. Die verbreitetste Art der Schnittstelle ist die nach dem REST-Standard, welche sich an eine Kommunikation über HTTP richtet (siehe \cref{sec:rest}).
 
Da viele Programmiersprachen den Informationsaustausch über HTTP ermöglichen, ist ein Microservice unabhängig von einer bestimmten Technologie. Jedes Team kann eigenständig entscheiden, welche Programmiersprache es verwenden will \parencite[vgl.][Kap. 1.2]{wolff_microservices_2018}. So können Sprachen nach Präferenz und Problemstellungen gewählt werden, ohne dass eine Inkompatibilität zum Rest des Systems entsteht.

Der Austausch über standardisierten Kommunikationswege ermöglicht, dass Services erstellt werden, die austauschbar sind \parencite[vgl.][Kap. 1.2]{wolff_microservices_2018}. Das hat zur Folge, dass z.B. einige Services durch Dienste von Drittanbietern ausgeführt werden und Entwicklungskosten eingespart werden. Es wird dadurch auch die Möglichkeit geschaffen auf bestehender Logik aufzubauen und ältere Systeme mit modernen Technologien zu verbinden.

Wie in \cref{sec:ddd} beschrieben, ermöglichen es Kontextgrenzen Microservices, Daten nach eigenem ermessen zu benennen und zu verwalten. Jeder Dienst besitzt eine eigene Datenspeicherung, z.B. in Form eines File-Storage-Systems oder einer Datenbank \parencite[vgl.][Kap. 2.1.3]{newman_monolith_2019}. Das bedeutet für das Gesamtsystem: keine einheitliche Datenspeicherung, jeder Service verwaltet die notwendigen Informationen eigenständig. Zum Erhalt der Funktionalität des gesamten Systems muss im Vorfeld bestimmt werden, wie der Informationsaustausch zwischen den Services abläuft \parencite[vgl.][Kap. 4.1]{wolff_microservices_2018}. Es muss festgelegt werden, welche Services welche Informationen verwalten und bei Abhängigkeiten zu anderen Diensten sind die Schnittstellen festzulegen. Insbesondere die genauen Endpunkt und die zu erwarteten Informationen müssen bestimmt werden. Die Handhabung innerhalb eines Services obliegt dann wieder dem einzelnen Team. 

Gibt es einen Service, der Informationen von einem anderen Dienst benötigt, fordert dieser die Daten über öffentliche Schnittstellen aktive an. Durch die Verwaltung identischer Informationen durch mehrere Diensten kommt es zu unterschieden Datenständen \parencite[vgl.][Kap. 4.1]{wolff_microservices_2018}. So besteht die Herausforderung, Informationen zwischen Services konsistent zu halten.

Die volle Unabhängigkeit eines Microservice kann nur erreicht werden, wenn dieser auch für die Benutzeroberfläche verantwortlich ist \parencite[vgl.][Kap. 4.4]{wolff_microservices_2018}. In der Praxis ist dies jedoch schwierig, da eine Webseite Inhalte von mehreren Services anzeigt. Besonders nach der Veröffentlichung von AngularJS\footnote{AngularJS ist ein JavaScript Framework, welches 2010 von Google entwickelt wurde und eine Open-Source-Software ist \parencite{angularjs}.}, gibt es immer mehr JavaScript Frameworks, die zur Verbesserung der Benutzererfahrung mehr Logik in das Frontend legen. React.js ist eines dieser Frameworks.
Die Beliebtheit dieser Frameworks besteht darin, dass jede Webseite nicht mehr als einzelne Seite betrachtet wird, sondern Informationen zwischen Benutzeroberflächen hinweg verwaltet werden \parencite[vgl.][Kap. 9.1]{wolff_microservices_2018}. Ein Datenabruf kann über mehrere Webseiten hinweg geteilt werden und die Performance wird verbessert. Das Routing zwischen den Webseiten wird durch das Framework verwaltet. Dieser Ansatz wird als Single-Page-Application (SPA) bezeichnet und unterscheidet sich von der Idee des Model-View-Controller (siehe \cref{sec:mvc}). Die nötigen Informationen werden aktive von der View geladen \parencite{single-page-webanwendung_2019}.

Auch kann es vorkommen, dass ein Microservices keine graphische Darstellung benötigt, da dieser ausschließlich E-Mails verschickt oder die beliebtesten Filme ermittelt. Folglich ist es umstritten, ob Microservice immer eine Benutzeroberfläche haben sollte.

Microservices bieten bezogen auf Skalierung viele Vorteile \parencite[vgl.][Kap. 2.1.4]{newman_monolith_2019}. So lassen sich, unabhängig vom Gesamtsystem, intensiv genutzte Services individuell skalieren. Kosten können eingespart werden, da nur einem einzelnen Teil und nicht das gesamte System mehr Ressourcen zu geteilt werden. Auf Basis der eingeteilten Teams werden weitere Entwickler angestellt und das Unternehmen wächst personell.

Während Microservices Skalierungen begünstigen, erschweren sie Service übergreifende Veränderungen \parencite[vgl.][Kap. 2.15]{newman_monolith_2019}. Auf Grund der technologischen Freiheit ist es aufwendiger, Entwickler von einem Service zu einem anderen zu überführen. Verstärkt wird dies durch die Speicherung unterschiedlicher Daten und die Verwendung verschiedener Terminologien. Die technologische Überführung von Funktionen wird durch den Einsatz von verschiedenen Programmiersprachen erschwert. Äquivalent ist das Zusammenführen von Datenschemata, welches durch die unterschiedlichen Attributbezeichnungen boykottiert wird. Dies führt dazu, dass ein Zusammenschluss nur durch einen großen Aufwand erreicht werden kann.

