\subsection{Kommunikation von Services}
\label{sec:kommunikation}

Eine Microservice-Architektur besteht aus einzelnen, unabhängigen Services, die voneinander entkoppelt sind (siehe \cref{sec:microservices}). Um die Funktionalität des Gesamtsystems zu gewährleisten, müssen die einzelnen Services untereinander im Austausch stehen. Die Grundvoraussetzung für das Implementieren einer Microservice-Architektur ist deshalb die Kommunikation und das Vorhandensein eines kommunikationsfähigen Netzwerks.

Im Vergleich zu einem monolithischen System hat der Austausch von einzelnen Services über ein Netzwerk einige Nachteile \parencite[vgl.][Kap. 6.1]{wolff_microservices_2018}:
\begin{itemize}
	\item Höherer Aufwand bei der Absicherung eines Systems aus einzelnen Komponenten vor Angriffen
	\item Erhöhtes Risiko für potenzielle Angriffe, da jede öffentliche Schnittstelle angreifbar ist
	\item Aufrufe über das Netzwerk sind langsamer, als Aufrufe innerhalb eines Prozesses
\end{itemize}

Neben der Kommunikation über den REST-Standard gibt es weitere Arten der Kommunikation, wie GraphQL \parencite{graphql_docs} und gRPC \parencite{grpc_docs}. Diese wurden in den letzten fünf Jahren entwickelt und setzten andere Schwerpunkte.

Im Unterschied zu REST wird bei GraphQL nicht für jeden individuellen Client eine separate Schnittstelle geschrieben \parencite[vgl.][]{graphql_docs}. Bei dem Aufruf gibt der Client die Informationen mit, die er erhalten möchte. Im Vorfeld wird über ein Schema festgelegt, welche Informationen der Server zur Verfügung stellt \parencite[vgl.][]{graphql_docs}. So können über GraphQL nicht nur Informationen von einer Relation (Tabelle) abgerufen werden, es kann auch über Verbindungen zwischen Relationen, auf Daten von anderen Tabellen zugegriffen werden \parencite[vgl.][]{graphql_docs}. Auch hier wird die Spezifikation der Inhalte vom Client beim Aufrufen der Schnittstelle mitgegeben. Es entstehen so wenige Programmschnittstellen, die jedoch eine Vielzahl Anforderungen bedienen können. Von Bedeutung ist dies für Aggregierte Informationen aus mehreren Tabellen, sowie für Systeme, in denen mehrere Clients unterschiedliche Informationen vom selben Service abrufen.

gRPC ermöglicht einem Client, Funktionen eines Servers über das Netzwerk aufzurufen, als wären sie in der gleichen Codebase \parencite[vgl.][]{grpc_docs}. Hierbei ist gRPC Programmiersprachen unabhängig, sodass ein in Java geschriebener Client auf ein Python-Server zugreifen kann. Im Gegensatz zum REST-Standard, der für Web-Anwendungen erstellt wurde, entwickelte Google gRPC speziell für den Austausch unter Services \parencite[vgl.][]{grpc_docs}. gRPC ermöglicht das Monitoren der Kommunikation zwischen Services, um auftretende Fehler schneller zu erkennen \parencite[vgl.][]{grpc_docs}. Es nutzt den moderneren HTTP/2 Standard \parencite[vgl.][]{grpc_wiki_2020}. Dadurch ist der Informationsaustausch stärker komprimiert als beim HTTP/1 Standard, wodurch der Datenaustausch schneller ist \parencite[vgl.][]{hypertext_wiki_2020}.

Seit der Beschreibung der Microservice-Architektur, als einzelne REST-Services\footnotemark, wurden neue Technologien zur Kommunikation zwischen Services entwickelt. Besondere gRPC besitzt auf Grund der moderneren Technik bedeutende Vorteile. Die Kommunikation zwischen entkoppelten Services ist jedoch langsamer als Aufrufe innerhalb eines Prozesses und bringen einige Nachteile mit sich.
\footnotetext{Peter Rodgers beschrieb 2005 auf der Web Services Edge Conference Micro-Web Services als REST-Services \parencite[vgl.][]{rodgers_peter}.}

Neben der Auswahl des Kommunikationsstandards muss ein Netzwerk vorliegen, dass sowohl einen hohen Durchsatz als auch eine hohe Geschwindigkeit ermöglicht und der Zugriff vor Unbefugten gesichert ist.
