\subsection{Kommunikation von Services}
\label{sec:kommunikation}
%Todo Literatur einfügen

Eine Microservicearchitektur besteht, wie in \cref{sec:microservices} beschrieben, aus einzelnen, unabhängigen Services besteht, die voneinander entkoppelt sind. Um die Funktionalität des Gesamtsystems zu gewährleisten, müssen die einzelnen Services untereinander im Austausch stehen. Die Grundvoraussetzung für das Implementieren einer Microservicearchitektur ist deshalb die Kommunikation und das Vorhandensein eines kommunikationsfähigen Netzwerks.

Im Vergleich zu einem monolithen System hat der Austausch von einzelnen Services über ein Netzwerk einige Nachteile:
\begin{itemize}
	\item Höherer Aufwand bei der Absicherung eines Systems aus einzelnen Komponenten vor Angriffen
	\item Erhöhtes Risiko für potenzielle Angriffe, da jede öffentliche Schnittstelle angreifbar ist
	\item Aufrufe über das Netzwerk sind langsamer, als Aufrufe innerhalb eines Prozesses \parencite[vgl.][Kap. 6.1]{wolff_microservices_2018}.
\end{itemize}

Neben der Kommunikation über den REST-Standard gibt es weitere Arten der Kommunikation wie GraphQL \parencite{graphql_docs} und gRPC \parencite{grpc_docs}. Diese wurden in den letzten fünf Jahren entwickelt und setzten deutlich andere Schwerpunkte.

Im Unterschied zu REST wird bei GraphQL nicht für jeden individuellen Client eine separate Schnittstelle geschrieben. Beim Aufruf gibt der Client die Informationen mit, welche er erhalten möchte \parencite[vgl.][]{graphql_docs}. Im Vorfeld wird über ein Schema festgelegt, welche Informationen der Server zur Verfügung stellt. So können über GraphQL nicht nur Informationen von einer Relation (Tabelle) abgerufen werden, es kann auch über Verbindungen zwischen Relationen, auf Daten von anderen Tabellen zugegriffen werden. Auch hier wird die Spezifikation der Inhalte vom Client beim Aufrufen der Schnittstelle mitgegeben. Es entstehen so wenige Programmschnittstellen, die jedoch eine Vielzahl Anforderungen bedienen können. Von Bedeutung ist dies für Aggregierte Informationen aus mehreren Tabellen, sowie für Systeme, in denen mehrere Clients unterschiedliche Informationen vom selben Service abrufen.

gRPC ermöglicht einem Client, Funktionen eines Servers über das Netzwerk aufzurufen, als wären sie in der gleichen Codebase. Hierbei ist gRPC Programmiersprachen unabhängig, sodass ein in Java geschriebener Client auf ein Python-Server zugreifen kann. Im Gegensatz zum REST-Standard, der für Web-Anwendungen erstellt wurde, entwickelte Google gRPC speziell für den Austausch unter Services. So werden keine Statuscodes oder andere Meta-Daten verschickt, sodass die Geschwindigkeit im Vergleich zum REST-Standard schneller ist. Des Weiteren ermöglicht gRPC das Monitoren der Kommunikation zwischen Services, um auftretende Fehler schneller zu erkennen. gRPC den moderneren HTTP/2 Standard, wodurch der Datenaustausch beschleunigt und optimiert wird.

Seit der Beschreibung der Microservicearchitektur als ein System aus einzelnen REST-Services durch Peter Rodgers 2005 wurden neue Technologien zur Kommunikation zwischen Services entwickelt. Insbesondere gRPC besitzt auf Grund der moderneren Technik bedeutende Vorteile bezogen auf die Geschwindigkeit. Jedoch ist die Kommunikation zwischen entkoppelten Services langsamer als Aufrufe innerhalb eines Prozesses und bringen einige Nachteile mit sich.

Neben der Auswahl des Kommunikationsstandards muss ein Netzwerk vorliegen, das sowohl einen hohen Durchsatz als auch eine hohe Geschwindigkeit ermöglicht und vor Angriffe gesichert werden kann.
